import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Stack;

/*
 * Likely TODO:
 * write pathfinding algorithm for pushing and pulling boxes to & from coords
 * findpath only finds walkable path, not pushable
 * the existing one can be reused, just use a different createWalkableCells()
 * which only creates neighbouring cells in which the opposite end is free
 * (and therefore pushable)
 * 
 * Create tunnelPush() check to weed out redundant states.
 * 
 * refactor class, this seems to be something needed to be done all the time.
 * 
 */
public class Bond implements Agent{

	int[][] counterMap;
	int boardWidth;
	int boardHeight;
	PriorityQueue<Board> states = new PriorityQueue<Board>();
	HashSet<String> passedStates = new HashSet<String>();
	private boolean[][] guaranteedDeadlocks;
	private final int MAX_PATH_SIZE = 300;
	//	static boolean[][] deadlockMatrix;


	@Override
	public String solve(Board solveBoard) {


		Board board = solveBoard;
		//		System.out.println("solve");
		boardHeight = board.getHeight ();
		boardWidth = board.getWidth ();
		guaranteedDeadlocks = Tools.createMatrix(solveBoard);
		//		deadlockMatrix = calculateDeadlock (board);
		Tools.printBipartiteArray(guaranteedDeadlocks, boardHeight, boardWidth);
		if (boardHeight > 1){
			//			Tools.doWalk("LDLRDRUDRRUDRRDDLLLLLUDRRRRRUULLLLULLDLLURUUUURRRRRDDDDLDRLLLURDRRUUUUULLLLLDDDDRLUUUURRRRRDDDDDLLLLULUUUURRRRRDDDDDLLURDRULDLLDDRRRRRUULLLRRRDDLLLLLUULULUUUURRRRRDDDDLLLRRRUUUULLLLLDDDDLDRUUUUURRRRRDDDDLLLUURDLDDDDRRRRRUUUL", board);
			//			return "LDLRDRUDRRUDRRDDLLLLLUDRRRRRUULLLLULLDLLURUUUURRRRRDDDDLDRLLLURDRRUUUUULLLLLDDDDRLUUUURRRRRDDDDDLLLLULUUUURRRRRDDDDDLLURDRULDLLDDRRRRRUULLLRRRDDLLLLLUULULUUUURRRRRDDDDLLLRRRUUUULLLLLDDDDLDRUUUUURRRRRDDDDLLLUURDLDDDDRRRRRUUUL";
		}
		//		board.printMap();
		//		System.out.println("original");
		//		board.printMap();
		states.add(board);
		String path = "";
		while (!states.isEmpty()) {
			Board state = states.poll();
			if (passedStates.contains(state.hash()))
				continue;
			if (state.isSolved()) {
				System.out.println("We did it");
				//				state.printMap();
				path = state.getPath().toString();
				break;
			} else {
				passedStates.add(state.hash ());
				try {
					ArrayList<Board> matchedBoxes = getNaiveBoxMatch (state);
					if (matchedBoxes != null){
						for (Board b : matchedBoxes)
							states.offer(b);
					}
				} catch (Exception e) {
					e.printStackTrace();
				}
				for (Coords c : state.getBoxes()) {
					for (Board b : moveBox(state,c))
						states.offer(b);
				}


			}
		}
		//		System.out.println ("Solution: "+path);
		//		Tools.doWalk(path, board);
		return path;
	}


	public ArrayList<Board> getNaiveBoxMatch(Board state) throws Exception {
		CoordPair[] matches = Matcher.getMatch(state);
		if (matches == null || matches.length < 1)
			return null;
		Board newBoard = state.clone();
		//		System.out.println ("Found "+matches.length+" matches for map:");
		//		for (CoordPair p : matches)
		//			System.out.println(p.toString()+": "+p.p.toString());
		//		newBoard.printMap();
		Coords from = matches[0].from;

		ArrayList<Board> matchStates = new ArrayList<Board> ();
		while (matches != null && matches.length>0){
			CoordPair match = matches[0];
			from = match.from;
			Board moved = performBoxMoveToCoords (from, match.to, match.p, newBoard);
			if (moved != null){
				matchStates.add(moved);
				newBoard = moved;
				newBoard.modScore(2000);
				from = newBoard.getPlayer();
			}
			matches = Matcher.getMatch(moved);

		}
		//		System.out.println ("After moving:");
		//		newBoard.printMap();
		return matchStates;
	}

	/**
	 * Performs some mutations of a state. Tries to move a box to any goals,
	 * and moves the box one step in all possible directions.
	 * @param board
	 * @param inFrom
	 * @return a list of states generated by the moves performed
	 */
	private ArrayList<Board> moveBox(Board board,Coords inFrom) {
		ArrayList<Board> allDirs = moveBoxInAllDirections (board, inFrom);
		ArrayList<Board> goalMoves = moveBoxToAllGoals (board, inFrom, false);
		allDirs.addAll(goalMoves);
		return allDirs;
	}
	/**
	 * Tries to move a box to all goals, and returns a list of the states where this was successful
	 * @param board
	 * @param inFrom
	 * @param ignoreBoxes if boxes are to be ignored while pushing (treated as walkable)
	 * @return
	 */
	private ArrayList<Board> moveBoxToAllGoals(Board board, Coords inFrom, boolean ignoreBoxes) {
		Coords[] goals = board.getGoals();
		Coords from = new Coords (inFrom.x, inFrom.y);
		ArrayList<Board> boards = new ArrayList<Board> ();
		for (Coords c : goals){
			if (board.getTileAt(c) == Surf.goal){
				addState (moveBoxToCoords (from, c, board, ignoreBoxes), boards);
			}
		}
		return boards;
	}
	/**
	 * Tries to move a box to given coords. Returns a new board with the move made.
	 * @param from
	 * @param to
	 * @param board
	 * @param ignoreBoxes
	 * @return
	 */
	private Board moveBoxToCoords (Coords from, Coords to, Board board, boolean ignoreBoxes){
		Path pathToPos = Pathfinder.findPushablePath (from, to, board);
		if (pathToPos == null)
			return null;
		return performBoxMoveToCoords (from, to, pathToPos, board);
	}
	/**
	 * Pushes boxes on a board according to the given path and coordinates.
	 * @param from
	 * @param to
	 * @param p
	 * @param b
	 */
	public Board performBoxMoveToCoords (Coords from, Coords to, Path p, Board b){
		char[] path = p.toString().toCharArray();
		for (char step : path){
			Board.Direction dir = null;
			switch (step){
			case 'U': dir = Board.Direction.UP;break;
			case 'D': dir = Board.Direction.DOWN;break;
			case 'L': dir = Board.Direction.LEFT;break;
			case 'R': dir = Board.Direction.RIGHT;break;
			}
			b = moveBox (from, dir, b);
			if (b == null)
				break;
			from = CoordHelper.nextCoordInDirection(dir, from);
		}
		return b;
	}
	/**
	 * Tries to move a box in all four directions, and saves every successful permutation state
	 * @param board
	 * @param inFrom
	 * @return all successful states resulting from the movements
	 */
	private ArrayList<Board> moveBoxInAllDirections(Board board,Coords inFrom) {
		Coords from = new Coords (inFrom.x, inFrom.y);
		ArrayList<Board> boards = new ArrayList<Board> ();
		addState (moveBox(from, Board.Direction.UP, board), boards);
		addState (moveBox(from, Board.Direction.DOWN, board), boards);
		addState (moveBox(from, Board.Direction.LEFT, board), boards);
		addState (moveBox(from, Board.Direction.RIGHT, board), boards);
		return boards;
	}

	private void addState(Board board, ArrayList<Board> boards) {
		if (board != null)
			boards.add(board);
	}

	private Board moveBox(Coords inFrom, Board.Direction inTo, Board board) {
		return moveBox(inFrom, inTo, board, false, false);
	}
	/**
	 * Moves a box in the given direction.
	 * Push will fail if:
	 * destination causes bipartite deadlock (guaranteedDeadlocks[dest] == true)
	 * player pushing position or destination square is not empty/goal
	 * there is no path from the player's current position to the pushing position
	 * @param inFrom the box to be pushed
	 * @param inTo direction of push
	 * @param board
	 * @param disregardBoxes wether to mind any boxes when pushing 
	 * @param ignoreTunnels 
	 * @return the state after the push, null if push failed
	 */
	private Board moveBox(Coords inFrom, Board.Direction inTo, 
			Board board, boolean disregardBoxes, boolean ignoreTunnels) {
		Coords player = board.getPlayer();
		//Copy Coords to avoid changing board state
		Coords from = new Coords (inFrom.x, inFrom.y);
		Coords to = CoordHelper.nextCoordInDirection(inTo, from);

		if (guaranteedDeadlocks[to.y][to.x])
			return null;

		Coords pushingPlayerPosition = Tools.getPushingPlayerPosition (inFrom, to);
		if (!board.isTileWalkable(pushingPlayerPosition, disregardBoxes) || !board.isTileWalkable(to, disregardBoxes))
			return null;

		Path pathToPos = Pathfinder.findPath (player, pushingPlayerPosition, board, Pathfinder.WalkMode.WALK);
		if (pathToPos == null)
			return null;
		if (board.getPath() != null){
			if (pathToPos.direction == '?')
				pathToPos = board.getPath();
			else
				pathToPos.getRoot().parent = board.getPath();
		}
		if (pathToPos.getSize() > MAX_PATH_SIZE)
			return null;
		Board newBoard = board.clone();
		if (passedStates.contains(newBoard))
			return null;
		newBoard.modScore(board.getScore());
		char movedDirection = Tools.getMovedDirection (inTo);
		Path movedPath = new Path (pathToPos, movedDirection);
		newBoard.setPath(movedPath);
		newBoard.getPlayer().x = pushingPlayerPosition.x;
		newBoard.getPlayer().y = pushingPlayerPosition.y;
		newBoard.movePlayer(inTo);
		if (BondHeuristics.deathSquare(to, newBoard)){
			return null;
		}
		if (board.getTileAt(from) == Surf.boxGoal && newBoard.getTileAt(to) == Surf.boxGoal)
			newBoard.modScore(-5);
		if (BondHeuristics.goalCorral (to, newBoard)){
			newBoard.removeBox(to);
			newBoard.removeGoal(to);
			newBoard.modScore(Integer.MAX_VALUE/2);
		}
		while (!ignoreTunnels && BondHeuristics.tunnelPush (from, to, inTo, newBoard)){
			//			System.out.println("Tunnel detected. pushing "+inTo);
			newBoard.movePlayer(inTo);
			newBoard.setPath(new Path (newBoard.getPath(), movedDirection));
			from = to;
			to = CoordHelper.nextCoordInDirection(inTo, from);
			newBoard.modScore(10);
		}
		newBoard.printMap();
		return newBoard;
	}
}
