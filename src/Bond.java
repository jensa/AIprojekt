import java.util.ArrayList;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Stack;

/*
 * Likely TODO:
 * write pathfinding algorithm for pushing and pulling boxes to & from coords
 * findpath only finds walkable path, not pushable
 * the existing one can be reused, just use a different createWalkableCells()
 * which only creates neighbouring cells in which the opposite end is free
 * (and therefore pushable)
 * 
 * Create tunnelPush() check to weed out redundant states.
 * 
 * refactor class, this seems to be something needed to be done all the time.
 * 
 */
public class Bond implements Agent{

	int[][] counterMap;
	int boardWidth;
	int boardHeight;
	Stack<Board> states = new Stack<Board>();
	HashSet<String> passedStates = new HashSet<String>();
	private boolean[][] guaranteedDeadlocks;
	private boolean[][] pullMatrix;
	//	static boolean[][] deadlockMatrix;


	@Override
	public String solve(Board solveBoard) {
		Board board = solveBoard;
		System.out.println("solve");
		boardHeight = board.getHeight ();
		boardWidth = board.getWidth ();
		pullMatrix = Tools.createPullMatrix(board);
		Tools.printBipartiteArray(pullMatrix, boardHeight, boardWidth);
		
		guaranteedDeadlocks = Tools.createMatrix(solveBoard);
		calculateAdditionalDeadlocks (board.noBoxClone());
		//		deadlockMatrix = calculateDeadlock (board);
		Tools.printBipartiteArray(guaranteedDeadlocks, boardHeight, boardWidth);
		if (boardHeight > 1){
//						return "";
		}
		//		board.printMap();
		System.out.println("original");
		board.printMap();
		states.add(board);
		String path = "";
		while (!states.isEmpty()) {
			Board state = states.pop();
			state.printMap();
			if (passedStates.contains(state.hash()))
				continue;
			if (state.isSolved()) {
				System.out.println("We did it");
				state.printMap();
				path = state.getPath();
				break;
			} else {
				passedStates.add(state.hash ());
				for (Coords c : state.getBoxes()) {
					for (Board b : moveBox(state,c))
						states.push(b);
				}
			}
		}
		return path;
	}
	
	/**
	 * TODO:
	 * Intended to calculate bipartite deadlocks before starting,
	 * by pulling boxes from all goals to all tiles, and filling out
	 * guaranteedDeadlocks afterwards with unvisited tiles.
	 * Before this can work however, we need a findPullablePath (from, to)
	 * @param b
	 */
	private void calculateAdditionalDeadlocks(Board b) {
		for (int i=0;i<b.getHeight();i++){
			for (int j=0;j<b.getWidth();j++){
				Coords cell = new Coords (j,i);
				if (b.getTileAt(cell) == Surf.wall || b.getTileAt(cell) == Surf.goal)
					continue;
				boolean foundPath = false;
				for (Coords c : b.getGoals()){
					String pullPath = Pathfinder.findPullablePath(c, cell, b);
					if (!pullPath.equals("")){
						foundPath = true;
						break;
					}
				}
				if (!foundPath){
					guaranteedDeadlocks[i][j] = true;
				}
			}
		}
	}

	private Board.Direction[] pushBoxPath(Coords fromCoords, Coords toCoords, Board b) {
	    Coords box = fromCoords;
	    
		
	    
	    return null;
	}
	
	/**
	 * Performs a walk through a given path,
	 * useful mostly for debugging
	 * @param path
	 * @param board
	 */
	private void doWalk(String path, Board board) {
		char[] pathc = path.toCharArray();
		Board b = board;
		for (char step : pathc){
			Board.Direction dir = null;
			switch (step){
			case 'U': dir = Board.Direction.UP;break;
			case 'D': dir = Board.Direction.DOWN;break;
			case 'L': dir = Board.Direction.LEFT;break;
			case 'R': dir = Board.Direction.RIGHT;break;
			}
			board.movePlayer(dir);
			board.printMap();
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	/**
	 * Performs some mutations of a state. Tries to move a box to any goals,
	 * and moves the box one step in all possible directions.
	 * 
	 * TODO: moving the box to the goal usually does not work.
	 * A findPushablePath (from, to) is needed to make it work.
	 * Right now it finds only the shortest walkable path, and if pushing the box is unsuccessful it drops the state
	 * without trying other paths (because findPath () only finds shortest path)
	 * @param board
	 * @param inFrom
	 * @return a list of states generated by the moves performed
	 */
	private ArrayList<Board> moveBox(Board board,Coords inFrom) {
		ArrayList<Board> goalMoves = new ArrayList<Board> ();//moveBoxToGoal (board, inFrom, false); //
		goalMoves.addAll(moveBoxInAllDirections (board, inFrom));
		// Move all boxes to a goal. 
		//goalMoves.add(moveBoxToGoal(board, inFrom));
		return goalMoves;
	}
	
	/**
	 * Tries to move a box to all goals, and returns a list of the states where this was successful
	 * @param board
	 * @param inFrom
	 * @param ignoreBoxes if boxes are to be ignored while pushing (treated as walkable)
	 * @return
	 */
	private ArrayList<Board> moveBoxToGoal(Board board, Coords inFrom, boolean ignoreBoxes) {
		Coords[] goals = board.getGoals();
		Coords from = new Coords (inFrom.x, inFrom.y);
		ArrayList<Board> boards = new ArrayList<Board> ();
		for (Coords c : goals){
			if (board.getTileAt(c) == Surf.goal){
				addState (moveBoxToCoords (from, c, board, ignoreBoxes), boards);
			}
		}
		return boards;
	}

	
	/**
	 * Tries to move a box to given coords.
	 * TODO:
	 * This doesn't work very well. it currently finds the shortest walkable path and tries
	 * to push the box along that path. If that fails, it gives up on it completely.
	 * We need a findPushablePath (from, to) to use this properly.
	 * @param from
	 * @param to
	 * @param board
	 * @param ignoreBoxes
	 * @return
	 */
	private Board moveBoxToCoords (Coords from, Coords to, Board board, boolean ignoreBoxes){
		String pathToPos = Pathfinder.findPushablePath (from, to, board);
		if (pathToPos == null)
			return null;
		char[] path = pathToPos.toCharArray();
		Board b = board.clone();
		for (char step : path){
			Board.Direction dir = null;
			switch (step){
			case 'U': dir = Board.Direction.UP;break;
			case 'D': dir = Board.Direction.DOWN;break;
			case 'L': dir = Board.Direction.LEFT;break;
			case 'R': dir = Board.Direction.RIGHT;break;
			}
			b = moveBox (from, dir, b, ignoreBoxes);
			if (b == null)
				return null;
			from = CoordHelper.nextCoordInDirection(dir, from);

		}
		return b;
	}
	/**
	 * Tries to move a box in all four directions, and saves every successful permutation state
	 * @param board
	 * @param inFrom
	 * @return all successful states resulting from the movements
	 */
	private ArrayList<Board> moveBoxInAllDirections(Board board,Coords inFrom) {
		Coords from = new Coords (inFrom.x, inFrom.y);
		ArrayList<Board> boards = new ArrayList<Board> ();
		addState (moveBox(from, Board.Direction.UP, board), boards);
		addState (moveBox(from, Board.Direction.DOWN, board), boards);
		addState (moveBox(from, Board.Direction.LEFT, board), boards);
		addState (moveBox(from, Board.Direction.RIGHT, board), boards);
		return boards;
	}

	private void addState(Board board, ArrayList<Board> boards) {
		if (board != null)
			boards.add(board);
	}
	
	private boolean isDeadLockBoard(Board b, Coords to) {
		if (guaranteedDeadlocks[to.y][to.x])
			return true;
		if (!pullMatrix[to.x][to.y])
			return true;
		if (isSquare(b))
			return true;
		return false;
	}
	
	private boolean isSquare(Board b) {
		Coords[] boxes = b.getBoxes();
		for (int i = 0; i < boxes.length; i++) {
			int x = boxes[i].getX();
			int y = boxes[i].getY();
			
			boolean xplus1 = b.isTileWalkable(new Coords(x+1,y)) || b.getTileAt(new Coords(x+1,y)) == Surf.boxGoal;
			boolean xplus1yplus1 = b.isTileWalkable(new Coords(x+1,y+1)) || b.getTileAt(new Coords(x+1,y+1)) == Surf.boxGoal;
			boolean yplus1 = b.isTileWalkable(new Coords(x,y+1)) || b.getTileAt(new Coords(x,y+1)) == Surf.boxGoal;
			
			boolean xplus1yminus1 = b.isTileWalkable(new Coords(x+1,y-1))|| b.getTileAt(new Coords(x+1,y-1)) == Surf.boxGoal;
			boolean xyminus1 = b.isTileWalkable(new Coords(x,y-1)) || b.getTileAt(new Coords(x+1,y-1)) == Surf.boxGoal;
			
			boolean xminus1yminus1 = b.isTileWalkable(new Coords(x-1,y-1)) || b.getTileAt(new Coords(x-1,y-1)) == Surf.boxGoal;
			boolean xminus1 = b.isTileWalkable(new Coords(x-1,y)) || b.getTileAt(new Coords(x-1,y)) == Surf.boxGoal;
			
			boolean xminus1yplus1 = b.isTileWalkable(new Coords(x-1,y+1)) || b.getTileAt(new Coords(x-1,y+1)) == Surf.boxGoal;
			boolean xyplus1 = b.isTileWalkable(new Coords(x,y+1)) || b.getTileAt(new Coords(x,y+1)) == Surf.boxGoal;
			
			boolean deadLock = false;
			if ( !xplus1 && !xplus1yplus1 && !yplus1) {
				deadLock = true;
			} else if ( !xplus1yminus1 && !xyminus1 && !xplus1yplus1) {
				deadLock = true;
			} else if ( !xyminus1 && !xminus1yminus1 && !xminus1) {
				deadLock = true;
			} else if ( !xminus1 && !xminus1yplus1 && !xyplus1) {
				deadLock = true;
			}
			
			if (deadLock)
				//b.printMap();
				return deadLock;
		}
		return false;
	}

	private Board moveBox(Coords inFrom, Board.Direction inTo, Board board) {

		return moveBox(inFrom, inTo, board, false);
	}
	/**
	 * Moves a box in the given direction.
	 * Push will fail if:
	 * destination causes bipartite deadlock (guaranteedDeadlocks[dest] == true)
	 * player pushing position or destination square is not empty/goal
	 * there is no path from the player's current position to the pushing position
	 * BondHeuristics considers any box to cause a deadlock
	 * @param inFrom the box to be pushed
	 * @param inTo direction of push
	 * @param board
	 * @param disregardBoxes wether to mind any boxes when pushing 
	 * @return the state after the push, null if push failed
	 */
	private Board moveBox(Coords inFrom, Board.Direction inTo, 
			Board board, boolean disregardBoxes) {
		Coords player = board.getPlayer();
		//Copy Coords to avoid changing board state
		Coords from = new Coords (inFrom.x, inFrom.y);
		Coords to = CoordHelper.nextCoordInDirection(inTo, from);

		if (isDeadLockBoard(board, to))
			return null;
		
		Coords pushingPlayerPosition = Tools.getPushingPlayerPosition (inFrom, to);
		if (!board.isTileWalkable(pushingPlayerPosition, disregardBoxes) || !board.isTileWalkable(to, disregardBoxes))
			return null;

		String pathToPos = Pathfinder.findPath (player, pushingPlayerPosition, board, Pathfinder.WalkMode.WALK);
		if (pathToPos == null || pathToPos.equals(""))
			return null;

		Board newBoard = board.clone();
//		newBoard.modScore(board.getScore()*10);
		String movedDirection = Tools.getMovedDirection (inTo);
		if (!newBoard.appendPath(pathToPos+movedDirection))
			return null;

		newBoard.getPlayer().x = pushingPlayerPosition.x;
		newBoard.getPlayer().y = pushingPlayerPosition.y;
		newBoard.movePlayer(inTo);
		//		if (board.getTileAt(from) == Surf.boxGoal && newBoard.getTileAt(to) == Surf.boxGoal)
		//			newBoard.modScore(-1000);

		while (BondHeuristics.tunnelPush (from, to, newBoard)){
			newBoard.movePlayer(inTo);
		}
		//newBoard.printMap();
		return newBoard;
	}
}
